const c = @cImport({
    @cInclude("snappy-c.h");
});

pub const Error = error{
    invalid_input,
    buffer_too_small,
};

fn check(result: c_uint) Error!void {
    switch (result) {
        0 => {},
        1 => return Error.invalid_input,
        2 => return Error.buffer_too_small,
        else => unreachable,
    }
}

/// Takes the data stored in `input` and stores it to `compressed`.
///
/// If `compressed.len` is not at least equal to `maxCompressedLength(input_length)`,
/// `Error.buffer_too_small` is returned.
///
/// After successful compression,
/// the true length of the compressed output is returned.
pub fn compress(input: []const u8, compressed: []u8) Error!usize {
    var compressed_length = compressed.len;
    try check(c.snappy_compress(
        input.ptr,
        input.len,
        compressed.ptr,
        &compressed_length,
    ));
    return compressed_length;
}

/// Given data in `compressed` generated by calling `compress()`,
/// this routine stores the uncompressed data to `uncompressed`.
///
/// Returns `Error.invalid_input` if the message
/// is corrupted and could not be decrypted.
///
/// If `uncompressed.len` is not at least equal to the value returned by
/// `uncompressedLength` for this stream,
/// `Error.buffer_too_small` is returned.
///
/// After successful decompression,
/// the true length of the decompressed output is returned.
pub fn uncompress(compressed: []const u8, uncompressed: []u8) Error!usize {
    var uncompressed_length = uncompressed.len;
    try check(c.snappy_uncompress(
        compressed.ptr,
        compressed.len,
        uncompressed.ptr,
        &uncompressed_length,
    ));
    return uncompressed_length;
}

/// Returns the maximal size of the compressed representation of
/// input data that is `source_length` bytes in length.
pub fn maxCompressedLength(source_length: usize) usize {
    return c.snappy_max_compressed_length(source_length);
}

/// REQUIRES: `compressed` was produced by `compress()`
///
/// Returns the length of the uncompressed data normally.
///
/// Returns `Error.invalid_input` on parsing error.
///
/// This operation takes O(1) time.
pub fn uncompressedLength(compressed: []const u8) Error!usize {
    var uncompressed_length: usize = 0;
    try check(c.snappy_uncompressed_length(
        compressed.ptr,
        compressed.len,
        &uncompressed_length,
    ));
    return uncompressed_length;
}

/// Check if the contents of `compressed` can be uncompressed successfully.
/// Does not return the uncompressed data;
/// if not, returns `Error.invalid_input`.
///
/// Takes time proportional to `compressed.len`, but is usually at least a
/// factor of four faster than actual decompression.
pub fn validateCompressedBuffer(compressed: []const u8) Error!void {
    try check(c.snappy_validate_compressed_buffer(
        compressed.ptr,
        compressed.len,
    ));
}

const testing = @import("std").testing;

test {
    const allocator = testing.allocator;

    const input = "Hello, Snappy!";
    const compressed = try allocator.alloc(u8, maxCompressedLength(input.len));
    defer allocator.free(compressed);

    const compressed_length = try compress(input, compressed);
    try validateCompressedBuffer(compressed[0..compressed_length]);

    const uncompressed = try allocator.alloc(u8, try uncompressedLength(compressed));
    defer allocator.free(uncompressed);

    const uncompressed_length = try uncompress(compressed[0..compressed_length], uncompressed);

    try testing.expectEqual(input.len, uncompressed_length);
    try testing.expectEqualSlices(u8, input, uncompressed[0..uncompressed_length]);
}
